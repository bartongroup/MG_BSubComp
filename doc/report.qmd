---
title: "Transcriptomic changes in *ΔcomA* and *ΔrapP* mutants in *Bacillus subtilis*"
author:
  - name: Marek Gierlinski
    affiliations: Data Analysis Group
    note: "Creator of this report"
  - name: Jonathan Griffin
    affiliations: Molecular Microbiology
  - name: Nicola Stanley-Wall
    affiliation: Molecular Microbiology
date: today
date-format: "D MMMM YYYY"
execute:
  echo: false
  cache: true
  warning: false
format:
  html:
    theme:
      - journal
      - report.scss
    toc: true
    number-sections: true
self-contained: true
editor: 
  markdown: 
    wrap: 72
---

```{r}
#| label: libraries
#| cache: false
suppressPackageStartupMessages({
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  library(purrr)
  library(forcats)
  library(stringr)
  library(targets)
  library(gt)
  library(cowplot)
})
tar_config_set(store = "../_targets")
```

```{r}
#| label: functions
N <- function(n) {
  prettyNum(n, big.mark = ",")
}

gt_table <- function(s) {
  s |> 
    gt::gt() |> 
    gt::tab_options(
      table.align = "center",
      heading.align = "center",
      data_row.padding = gt::px(3)
    ) |> 
    gt::opt_table_font(
      font = c(
        gt::default_fonts()
      )
    )
} 
```


```{r config}
tar_load(config)
```

# Proposal

## Samples and experiment

This RNAseq experiment aims to compare transcriptomic changes between 5 biological replicates of two *Bacillus subtilis* strains NRS6942 (Control NCIB 3610 *amyE::Phy-spank-gfp mut2 (cml)*) and NRS7771 (Experimental NCIB 3610 *amyE::Phy-spank-gfp mut2 (cml) ΔrapP ΔcomA::spec*). The strains were grown in the same conditions at 30°C on MSgg media agar plates for 20^h^.
 
The control strain NRS6942 is a mutant of the lab strain NCIB 3610, containing a GFP tag to amyE; the experimental strain NRS7771 is a mutant of that strain, in which the genes rapP and comA have also been knocked out. 

The experiment should be quite easy to analyse as there's only one contrast group (NRS6942-NRS7771). 
 
## Biological background

*B. subtilis* NCIB 3610 outcompetes other *Bacillus* strains; the project aimed to identify genetic changes that might allow the outcompeted strains to better compete and endure NCIB 3610. Through an untargeted evolution approach, the NSW lab generated various strains that were able to better compete. Analysis of these better-competing strains indicated that a mutation in the *comP* gene increased their survivability. To further analyse this, the NSW knocked out other genes (eg the transcription factor *comA*) in the *comQXPA* gene cluster to which *comP* belongs, as well as the *rapP* gene, another gene critical to quorum sensing and bacterial competition.
 
One such mutant, a *comA rapP* mutant line (NRS7771), was found to grow differently to its WT (NRS6942( (Figure below), indicating that both *comA* and *rapP* are important to Bacillus growth. We aimed to characterise the transcriptomic changes contributing to the changes in development.
 
The biological question is, how is the Bacillus transcriptome altered by mutation of comA and rapP? We are expecting there to be differences in cell division and reproduction, as well as in quorum sensing. Given the visual phenotype differences, we may also see changes in transcripts associated to biofilm development eg exopolysaccharides.
 

```{r, out.width="100%"}
#| label: fig-phenotypes
#| fig-cap: Observed phenotypes
knitr::include_graphics("images/phenotypes.png")
```
 

## What we're looking for

A full start-to-finish analysis for the RNAseq data. The reads will need checking via MD5s, trimming, and aligning to the reference genome for NCIB3610 (accessions are CP020102 for the chromosome and CP020103 for the plasmid pBS32- I think these are stored here Y:\\nrstanleywall\\fasta_genomes) and a fastQC to check they're ideal, followed by quantification for differential analysis.
 
Any tools and output showing significantly up- or down-regulated genes in the comparison group, ideally with adjP < 0.05 and with a log2 fold change of 1. I'd love to see the various outputs eg volcano plots we can generate using your tool suite!
 
For a first pass, a GO analysis would be helpful for painting a broad picture of the affected processes, after which we can hone in on interesting changes in operons and known regulatory pathways.

# Samples

There are two biological conditions (control and mutant), each in five replicates. Sample names are shown in @tbl-metadata.

```{r}
#| label: tbl-metadata
#| tbl-cap: Original sample names (as used in FASTQ file names) and simplified samples names used here.
tar_read(metadata) |> 
  select(`Original sample` = raw_sample, Sample = sample, Group = group, Replicate = replicate) |> 
  gt() 
```

# Software

The data analysis was conducted in two stages. The first stage was performed on the Life Sciences cluster using a Snakemake script. This stage included the cleaning, quality control, and mapping of FASTQ files. The software versions used in this stage are listed in @tbl-software. In the second stage, the data were imported into Positron and further processed using R on a MacBook Pro. The versions of the R packages utilized are provided in @sec-session-info. All code used in this project is available on [GitHub](https://github.com/bartongroup/MG_BSubComp). The results of these analyses are presented below.

```{r}
#| label: tbl-software
#| tbl-cap: Software used for cleaning, quality control and mapping FASTQ files.
tar_read(software_versions) |> 
  select(Software = name, Version = version) |> 
  gt() |> 
  cols_width(
    Software ~ px(150)
  ) 
```

# Genome and annotations

Bacillus subtilis NCIB 3610 [genome assembly ASM205596v1](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_002055965.1/) has been downloaded from NCBI (genome sequence and GTF annotations). It consists of two sequences, with GeneBank locus ID CP020102.1 for the chromosome and CP020103.1 for the plasmid. The lengths of the chromosome and plasmid are 4,215,607 and 84,215 bp, respectively.

## Annotating plasmid

Alas, the NCBI genome does not come with gene names in the plasmid. All genes in the plasmid are annotated only by a locus ID, e.g. B4U62_RS22265. [Konkol, Blair and Kearns (2013)](https://pmc.ncbi.nlm.nih.gov/articles/PMC3754741/) annotated genes in the plasmid. Quote: "We have annotated and submitted to GenBank 102 genes carried by pBS32, named by using the following nomenclature: zpxX, where the x's are sequential letters clockwise from the repN gene encoding an essential replication protein (see GenBank accession number [KF365913](https://ncbi.nlm.nih.gov/nucleotide/KF365913) for individual gene annotations). Whereas genes of unknown function in the chromosome begin with the letter “y,” and genes carried by chromosomal prophages begin with the letter “x,” we chose the letter “z” to indicate genes of unknown function carried on the endogenous plasmid."

These annotations have been downloaded from GenBank[^1] and applied to the plasmid genes. One of the genes included in the new annotations is B4U62_RS22265, annotated as *rapP*.

[^1]: Alas, the GFF file is created on the fly, I don't know how to get it programmatically. We include the file in the GitHub repository for reproducibility.

## Annotating non-coding RNA

*SubtiWiki* contains more than 1500 features named *Sn*, where *n* is an integer, for example *S1450*. These represent non-coding RNAs, often overlapping with coding genes (@fig-s1450).


```{r, out.width="100%"}
#| label: fig-s1450
#| fig-cap: An example of a non-coding RNA *S1450*, overlapping with two protein coding genes *ywhL* and *ywhK*, but on the opposite strand.
knitr::include_graphics("images/S1449_S1450.png")
```


The ncRNA annotations were added to the NCBI's GTF used for this analysis in the following way. Sequences of ncRNAs were extracted from *SubtiWiki*, using their APIs. Each sequence was mapped to the NCBI genome, allowing for up to 2 mismatches and indels. All sequences, except one, were mapped successfully. The coordinates of the mapped ncRNAs were added to the GTF file, and this combined GTF was used for read mapping and the downstream analysis.

### Examples of ncRNA expression

@fig-s1450 shows genomic locus around *S1450*, which is overlapping with  *ywhK* and *ywhL* on the opposite strand. @fig-igv-s1450 shows the read coverage of this region. @fig-sense-example shows the proportion of antisense counts as a function of the gene expression, for the genes illustrated in @fig-s1450. The distinction between counts on the sense and antisense strands is made possible thanks to the stranded protocol, separating reads aligning to the same strand as the gene (sense) and the opposite strand to the gene (antisense). Only reads on the sense strand can originate from the transcript expressed by a given gene. Therefore, a high proportion of antisense counts indicate the expression of an overlapping gene on the opposite strand to a given gene.

The expression from *S1450* is low and majority of counts (in particular in the mutant) are on the antisense strand, therefore they originate from overlapping genes *ywhL* and *ywhK*.


```{r, out.width="100%"}
#| label: fig-igv-s1450
#| fig-cap: Read coverage for the region illustrated in @fig-s1450, for sample 1 (control, top panel) and sample 6 (mutant, bottom panel).
knitr::include_graphics("images/igv_example.png")
```


```{r}
#| label: fig-sense-example
#| fig-cap: Proportion of reads on the antisense strand as a function of the total read count on the sense strand (expression) for genes shown in @fig-s1450. *ywhK*, *ywhL* and *S1449* are highly differentially expressed with high expression in the mutant, but very low proportion of counts registered on the antisense strand. *albG* and *S1450* have low expression in both conditions and high proportion of the antisense strand counts, coming from the opposite strand genes. Presumably, *ywhK*, *ywhL* and *S1449* form an operon.
#| fig-width: 8
#| fig-height: 10
tar_read(fig_sense_example)
```

Just next *S1450* lies *S1449*, which can be seen in @fig-s1450, on the reverse strand. It looks like it might be a part of the operon *ywh*. And indeed, @fig-sense-example shows that *S1449* is highly differentially expressed between mutant and control, with low fraction of the antisense reads, while the overlapping *albG* is lowly expressed in both conditions. We can also see in @fig-top-sig that expression of *ywhK*, *ywhL* and *S1449* is highly correlated across all samples, so, presumably, they are belong to the same operon.

We note that non-coding genes with names starting with S are largely missing from predicted operons in *SubtiWiki* database. Our examples demonstrates that at least some of them should be assigned to operons.


# Sequencing and mapping

## Sequencing

Sequencing was carried out by Edinburgh Genetics. 2x100 bp paired-end stranded reads were provided.

## Ribosomal RNA removal

A tool [RiboDetector](https://github.com/hzi-bifo/RiboDetector) was used to remove reads matching ribosomal RNA from FASTQ files. RiboDetector is a machine learning tool that can recognize ribosomal RNA. @fig-ribo show no substantial ribosomal contamination in all samples except `mut_5`, where ~60% of reads are ribosomal. This is a potentially "bad" sample, its usability will be discussed below.

```{r}
#| label: fig-ribo
#| fig-cap: Proportion of ribosomal reads detected in each sample.
#| fig-width: 5
#| fig-height: 5
tar_read(fig_ribo_prop)
```

## FastQ screen

[FastQ screen](https://www.bioinformatics.babraham.ac.uk/projects/fastq_screen/) was used to map a sample of reads to several genomes to check for contamination. @fig-fscreen shows one hit one genome percentage. Note, the fill scale is logarithmic with grey indicating zero. There is no notable contamination from other organisms. As you can see in the figure `mut_5` has only about 35% of unique hits to *B. subtilis* genome--the low number is the result of ribosomal contamination (FastQ screen has been run on unfiltered reads, still containing ribosomal sequences).


```{r}
#| label: fig-fscreen
#| fig-cap: FastQ screen results. The figure shows one hit per one genome percentages, using trimmed reads, but with ribosomal sequences not removed.
#| fig-width: 4.5
#| fig-height: 4
tar_read(fig_fscreen) 
```

## Read quality

@fig-read-qual shows read quality as a function of base pair position, @fig-read-qual-clust shows hierarchical clustering based on read quality. This has nothing to do with biology, but rather shows potential batch effects related to sequencing or sample quality. We see that the sample `ctrl_5` stands out a bit.

```{r}
#| label: fig-read-qual
#| fig-cap: Read quality.
#| fig-width: 8
#| fig-height: 3
tar_read(fig_read_qual)
```

```{r}
#| label: fig-read-qual-clust
#| fig-cap: Clustering based on read quality.
#| fig-width: 4
#| fig-height: 3
tar_read(fig_read_qual_clust)
```

## Quality control report

[The full MultiQC report](https://www.compbio.dundee.ac.uk/user/mgierlinski/bsub_comp/doc/multiqc.html).


## Mapping

[STAR](https://github.com/alexdobin/STAR) was used to map reads to the reference genome ASM205596v1 downloaded from NCBI. The following parameters were used for creating the index:

```
 --genomeSAindexNbases 10
```

and for mapping:

```
--sjdbGTFfeatureExon gene
--sjdbGTFtagExonParentTranscript gene_id
--outFilterType BySJout
--outSAMtype BAM SortedByCoordinate
--outFilterMultimapNmax 2
--alignIntronMax 1
--limitBAMsortRAM 3000000000
--readFilesCommand zcat
--quantMode GeneCounts
```

The `--alignIntronMax 1` option prohibits splicing (STAR is a splice-aware aligner). The `--sjdbGTFfeatureExon gene` option is included both in mapping, because the GFT file does not have exons and `gene` is the main feature. `--sjdbGTFtagExonParentTranscript gene_id` turned out to be very important; the GTF file contains blank arguments `transcript_id ""` and the default value of `sjdbGTFtagExonParentTranscript` is `transcript_id`. This causes problems and incorrect counting.

## Strandedness

[infer_experiment.py](https://open.bioqueue.org/home/knowledge/showKnowledge/sig/rseqc-infer-experiment) script from package [RSeQC](https://rseqc.sourceforge.net/) was used to identify strandedness of data. @tbl-strand shows that majority of reads are explained by the reverse strand. This confirms that the reversely-stranded protocol, consistent with TruSeq chemistry, was used.

```{r}
#| label: tbl-strand
#| tbl-cap: Output from infer_experiment.py.
tar_read(tbl_strandedness) |> 
  select(Sample = sample, `Forward fraction` = forward_fraction, `Reverse fraction` = reverse_fraction) |> 
  gt()
```


## Mapping properties

@fig-star-log and @fig-map-count show mapping summaries. The 'bad' sample `mut_5` has about the half of the read count of other samples, due to ribosomal contamination - these figures show results from clean data, after ribosomal sequences removal. However, the percentage of uniquely mapped reads remain high for all samples, including `mut_5`.

```{r}
#| label: fig-star-log
#| fig-cap: STAR mapping properties. 
#| fig-width: 4
#| fig-height: 10
tar_read(fig_star_log) 
```

```{r}
#| label: fig-map-count
#| fig-cap: Input counts vs mapped and counted reads. Samples are ordered from the lowest to the highest percentage of uniquely mapped reads.
#| fig-width: 8
#| fig-height: 4
tar_read(fig_map_count)
```



## Full QC report

The full quality control report, collated by MultiQC, is available [here](https://www.compbio.dundee.ac.uk/user/mgierlinski/bsub_comp/doc/multiqc.html).

# Read count properties

This section contains general properties of mapped read counts.

## Expression distribution

@fig-sample-dist shows raw read count distribution. Again, sample `mut_5` shows lower count levels than the other samples.

```{r}
#| label: fig-sample-dist
#| fig-cap: Distribution of raw read counts per sample, before any normalisation or transformation. Black horizontal lines show the median of each sample.
knitr::include_graphics("../fig/sample_quasirandom.png") 
```

## Expression across the chromosome

@fig-bedgraph-chrom shows the read mapping distribution across the chromosome, in logarithmic scale. Note that this plot can be used as a reference for future pilot experiments, to confirm correct mapping across the chromosome.

```{r}
#| label: fig-bedgraph-chrom
#| fig-cap: Read pileup across chromosome NZ_CP020102.1 for all samples, in 1000-bp bins. The low-count gaps below ~1 Mbp corresponds to the location of ribosomal genes, removed during sample preparation.
#| fig-width: 8
#| fig-height: 12
tar_read(fig_bedgraphs) 
```

## PCA, clustering and correlation

Next figures are based on [regularised logarithm](https://rdrr.io/bioc/DESeq2/man/rlog.html) (rlog) of raw count data. @fig-properties shows Pearson's correlation coefficient between each pair of samples, PCA results and hierarchical clustering.

```{r}
#| label: fig-properties
#| fig-cap: A. Correlation matrix. B. PCA of rlog-transformed counts. C. Hierarchical clustering of samples based on rlog-transformed counts and correlation distance.
#| fig-width: 8
#| fig-height: 8
g1 <- tar_read(fig_distance_mat)
g2 <- tar_read(fig_pca) + theme(legend.position = "none")
g3 <- tar_read(fig_clustering) 
cowplot::plot_grid(g1, g2, g3, nrow = 2, labels = c("A", "B", "C"), rel_heights = c(1, 0.8))
```

# 'Bad' sample {#sec-bad-sample}

Sample `mut_5` shows strong ribosomal contamination. @fig-bad-sample shows a comparison of this sample with `mut_1`, which does not show strong contamination. @fig-good-sample shows two good samples for context. Apart from slightly increased noise, the main difference is in the expression of rRNA genes. `mut_5` has been retained in downstream analysis.

```{r}
#| label: fig-bad-sample
#| fig-cap: Comparison between a "good" sample `mut_1` and a "bad" sample `mut_5`. `mut_1` and `mut_5` in the plot are log~10~(normalised_count + 1). The plot shows the difference versus sum of these logarithms. It is a MA plot. The grey lines indicate arbitrary exponential decay lines, used to mark outstanding genes. Red dots indicate ribosomal RNA genes.
#| fig-width: 4
#| fig-height: 4
tar_read(fig_mut_1_5)
```

```{r}
#| label: fig-good-sample
#| fig-cap: As in @fig-bad-sample, but comparing two "good" samples.
#| fig-width: 4
#| fig-height: 4
tar_read(fig_mut_1_2)
```

# Silenced genes

@fig-rapp and @fig-coma show the read pileup from around *rapP* and *comA* loci. *rapP* shows no reads from 29,723 to 30,707 on the plasmid. *comA* shows no reads from 3,252,894 to 3,253,365 on the chromosome. These regions have been excised from the genome in the mutant.


```{r, out.width="100%"}
#| label: fig-rapp
#| fig-cap: Genomic track with read pileup from around rapP gene, which is marked here as "unassigned transcript 4467". The upper and lower tracks show ctrl_1 and mut_1, respectively.
knitr::include_graphics("images/igv_rapP.png") 
```

```{r, out.width="100%"}
#| label: fig-coma
#| fig-cap: Genomic track with read pileup from around comA gene. The upper and lower tracks show ctrl_1 and mut_1, respectively.
knitr::include_graphics("images/igv_comA.png") 
```


# Differential expression {#sec-de}

Only genes with at least 10 reads in at least one sample are used for differential expression. All samples were used. *edgeR* was used for differential expression between mutant and control.

## Statistically significant genes

```{r}
#| label: de-genes
tar_load(c(de_genes, de_operons))
```

The p-values were adjusted for multiple tests using a Benjamini-Hochberg approach, creating a corresponding false discovery rates (FDR). The significant genes are defined as FDR < `r config$fdr_limit` and |logFC| > `r config$logfc_limit`.

Please note that these results are not correct, as the multiple test corrections require tests to be independent. However, bacterial genes are clustered in operons, with strongly correlated expression. This will be (partially) addressed this in Section @sec-operons. Here, selecting only small FDR and large fold changes circumvents the independence issue to some extent.

## Results 

`r nrow(de_genes)` genes were found as statistically significant, according to the rules outlined above. @fig-de-results shows the volcano and MA plots with the differential expression results. @fig-top-sig shows the top 50 (by p-value) DE genes as a heatmap.

```{r}
#| label: fig-de-results
#| fig-cap: "Results from the differential expression analysis. Left: volcano plot, right: MA plot. Black points indicate significant genes."
#| fig-width: 8
#| fig-height: 4
tar_load(figs_de)
cowplot::plot_grid(figs_de$volcano, figs_de$ma)
```

```{r}
#| label: fig-top-sig
#| fig-cap: Heatmap showing relative change between conditions (rlog expression minus mean) for the top 50 DE genes.
#| fig-width: 6
#| fig-height: 10
tar_read(fig_top_sig_heatmap)
```


# Operons {#sec-operons}

Genes in bacteria are arranged in operons, clusters of co-transcribed genes that share a single promoter and are expressed together as a polycistronic mRNA. Therefore, expression of genes from the same operon is highly correlated. This makes multiple test correction in differential gene expression flawed, is the Benjamini-Hochberg method requires independent tests.

To circumvent this issue, genes were grouped into operon clusters, with raw count of each operon summed. The operon data were downloaded from [SubtiWiki](https://www.subtiwiki.uni-goettingen.de/v5/operons). This, however, does not solve the problem entirely, as the operon definitions are not unique. For example, gene *rpsA* belongs to six different operons, as listed in @tbl-rpsa-operons. The expression from these operons will be correlated.

```{r}
#| label: tbl-rpsa-operons
#| tbl-cap: Operons to which *rpsA* is assigned in SubtiWiki.
tar_read(operons) |> 
  select(-id) |> 
  dplyr::filter(gene_symbol == "rpsA") |> 
  rename(Gene = gene_symbol, Operon = operon) |> 
  gt()
```

## Results

Keeping this in mind, differential expression was carried out on operon data, using the same approach as in @sec-de. `r nrow(de_operons)` operons were found as statistically significant.

```{r}
#| label: fig-deo-results
#| fig-cap: "Results from the differential expression analysis on operons. Left: volcano plot, right: MA plot. Black points indicate significant genes."
#| fig-width: 8
#| fig-height: 4
tar_load(figs_de_ops)
cowplot::plot_grid(figs_de_ops$volcano, figs_de_ops$ma)
```

```{r}
#| label: fig-top-sig-ops
#| fig-cap: Heatmap showing relative change between conditions (rlog expression minus mean) for all of the DE operons.
#| fig-width: 8
#| fig-height: 20
tar_read(fig_top_sig_ops_heatmap) 
```


```{r}
n_ops_not_de_genes <- tar_read(cmp_genes_ops) |> 
  filter(genes_in_de == "") |> 
  nrow()
```

However, operon approach does not bring any new results. There are only `r n_ops_not_de_genes` differentially expressed operons that don't have at least one gene among the differentially expressed genes. In all cases this is due to the logFC limit, these operons have the |logFC| just above 1, while the corresponding genes have |logFC| just below one.

# Functional enrichment

## Data sources

GFT file from NCBI which was used for read counting contains GO-term mapping. This is used in the interactive data explorer (see @sec-resources).

KEGG database contains some functional mapping for *B. subtilis*, which is also used here.

[WikiPathways](https://www.wikipathways.org/) is a nice resource, but it returns only 3 functional terms mapped to 14 genes for *B. subtilis*.

*SubtiWiki* web site include pathways, but an attempt to download them using their API fails - it returns a successful, but empty response. I have enquired them about it - they responded saying it is not implemented yet.

[BsubCYc](https://bsubcyc.org/) is an large online resource, but requires paid subscription.

## Functional enrichment

Functional enrichment is calculated for each selection of genes in the Shiny interactive explorer. See @sec-resources.

## Gene set enrichment

### Explanation


```{r gse_stats}
tar_load(gse_example_stats)
tar_load(gse_random_stats) 
```


Gene Set Enrichment Analysis (GSEA) is a computational method that
determines whether a predefined set of genes shows statistically
significant, concordant differences between two biological states (e.g.,
treatment vs control). This method is typically used in the analysis of
genome-wide expression profiles.

To simplify, let's say you have a list of all the genes in a genome,
ranked from the most up-regulated to the most down-regulated in
inhibitor compared to control. A gene set is a group of genes that share
a common biological function. Here we use functional annotations from
Gene Ontology and KEGG. A set is a group of genes annotated
with the same functional term. GSEA asks if members of a particular gene
set are randomly distributed throughout the ranked list or primarily
found at the top or bottom of the list, indicating that they might be
involved in the disease process.

The enrichment score, ES, is calculated by walking down the ranked list
of genes (ordered by $-\log FC \times \log P$) and increasing a
running-sum statistic when we encounter a gene annotated with the term
and decreasing it when we encounter genes not annotated with the term.
The significance of ES is estimated by a permutation test. An example of a GSE plot for one functional term is shown in @fig-fg-example.

```{r}
#| label: fig-fg-example
#| fig-cap: !expr str_glue("Example of gene set enrichment for a term {gse_example_stats$term_id}, *{gse_example_stats$term_name}*. The fold changes are taken from the differential expression result of {gse_example_stats$contrast} contrast. The horizontal axis contains {gse_example_stats$n_genes_used} genes used in differential expression ranked according to fold change, up-regulated genes to the left, down-reguleted to the right. Vertical lines indicate {gse_example_stats$n_genes_in_term} genes annotated with term {gse_example_stats$term_id}. They are distributed non-randomly throughout the ranked list, and are primarily found at the bottom of the list (negative log-fold-changes). The leading edge is a subset of annotated genes from the highest rank to the peak of the green curves, there are {gse_example_stats$n_leading_edge} such genes.")
#| fig-width: 5
#| fig-height: 5
tar_read(fig_fg_example) 
```

The enrichment score is the extreme (positive or negative) value achieved by the green curve - represented by the dashed red line. @fig-fg-example shows that genes annotated with `r gse_example_stats$term_id` are not randomly distributed throughout the ranked list of genes, but they are concentrated towards the bottom of the ranked list (to the right in the figure), and are mostly (but not all of them) down-regulated.

In contrast, @fig-fg-example-rand shows GSE for GO term `r gse_random_stats$term_id`, *`r gse_random_stats$term_name`*, where genes annotated with this term are distributed randomly throughout the ranked list. The enrichment score is small and the result is not statistically significant.

```{r}
#| label: fig-fg-example-rand
#| fig-cap: !expr str_glue("Example of gene set enrichment for a GO term {gse_random_stats$term_id}, *{gse_random_stats$term_name}*. The fold changes are taken from the differential expression result of mutant vs control contrast. The genes annotated with this term are distributed randomly throughout the ranked list.")
#| fig-width: 5
#| fig-height: 5
tar_read(fig_fg_example_random) 
```

The **leading edge** is the subset of genes that contribute most to the enrichment score. In the case shown in @fig-fg-example these are genes to the right of the extreme value of the green curve.

### Results

Only KEGG analysis returns statistically significant (FDR < 0.05) functional terms. They are listed in @tbl-gsea-kegg.


```{r}
#| label: tbl-gsea-kegg
#| tbl-cap: Statistically significant (FDR < 0.05) functional terms/pathways from GSEA analysis, including GO-terms and KEGG pathways. Only a few KEGG pathways are statistically significant. NES is a normalised enrichment score. Negative value indicates the genes are downregulated between control and mutant.
tar_read(tbl_gse) |> 
  mutate(term_name = str_remove(term_name, "\\s\\-.+$")) |> 
  select(`Term ID` = term_id, Name = term_name, FDR = fdr, NES = nes, `Leading edge` = leading_edge) |> 
  gt() |> 
  gt::fmt_number(
    columns = FDR,
    n_sigfig = 2
  ) |> 
  gt::fmt_number(
    columns = NES,
    n_sigfig = 3
  )
```

# Toxins and antibiotics

```{r}
tar_load(toxan) 
n_toxan <- nrow(toxan)
n_on_ncbi <- toxan |> filter(ncbi) |> nrow()
n_not_on_ncbi <- toxan |> filter(!ncbi) |> nrow()
```

A list of `r n_toxan + 1` toxins and antibiotics was provided. At the first step, *pksK* was removed from the list, as it was found to be a synonym of *pksJ*, already on the list. Then the gene symbols on the list were matched to the NCBI annotations, where possible. `r n_on_ncbi` genes were found matching directly, by the gene symbol. The remaining `r n_not_on_ncbi` genes were matched to *SubtiWiki* annotations and then mapped to the NCBI data by coordinates, matching start and end of each gene within ±50 bp of the start and end of the NCBI coordinates, respectively. *yfjE* with a very different length in both sets of annotations was matched manually to B4U62_RS04555.

```{r}
#| label: tbl-toxan-match
#| tbl-cap: Results of matching toxins and antibiotics to the NCBI annotations. There are two different genes annotated as *ppsA* in NCBI. Here, they are distinguished by calling them *ppsA* and *ppsA.1*. The blue shading indicates genes with different names in the NCBI database than in the provided list, for which *SubtiWiki* annotations were used and then mapped by coordinates to the NCBI genes.
toxan |> 
  mutate(ncbi_gene = tidyr::replace_na(ncbi_gene, "--")) |> 
  select(chr, `Gene symbol` = gene_symbol, `Matching NCBI gene` = ncbi_gene, `NCBI id` = id, Start = start, End = end, ncbi) |> 
  group_by(chr) |> 
  gt() |> 
  tab_style(
    style = list(
      cell_fill(color = "lightskyblue1")
    ),
    locations = cells_body(
      rows = ncbi == FALSE
    )
  ) |> 
  cols_hide(ncbi)
```


@fig-volcano-toxan shows the volcano plot from the differential expression (as in @fig-de-results), with toxin and antibiotic genes highlighted. @fig-heatmap-toxan shows a heatmap of these genes. Finally, @tbl-de-toxan lists the differential expression results for these genes, highlighting the significant genes, separately for FDR and logFC.

```{r}
#| label: fig-volcano-toxan
#| fig-cap: Volcano plot with toxins and antibiotics highlighted. The horizontal lines indicate FDR limit of 0.01 and 0.05.
#| fig-width: 8
#| fig-height: 8
tar_read(fig_volcano_toxan) +
  ggplot2::theme(legend.position = "none")
```

```{r}
#| label: fig-heatmap-toxan
#| fig-cap: Heatmap with toxins and antibiotics highlighted. The colours show relative change of rlog expression with respect to the mean in each gene.
#| fig-width: 5
#| fig-height: 15
tar_read(fig_heatmap_toxan)
```


```{r}
#| label: tbl-de-toxan
#| tbl-cap: "Differential expression results for the toxin and antibiotics gene selection. Green background indicates two parts of the 'significant' selection: FDR < 0.01 and |logFC| > 1."
tar_read(de_toxan_sel) |> 
  select(ID = id, Gene = gene_symbol, logFC, FDR) |> 
  gt() |> 
  fmt_number(
    columns = c(logFC,  FDR),
    n_sigfig = 2
  ) |> 
  data_color(
    columns = logFC,
    rows = abs(logFC) > 1,
    method = "numeric",
    palette = "green"
  ) |> 
    data_color(
    columns = FDR,
    rows = FDR < 0.01,
    method = "numeric",
    palette = "green"
  )
```


# Resources {#sec-resources}

## Interactive data explorer {#sec-shiny-app}

- [Differential expression for genes](https://shiny.compbio.dundee.ac.uk/mgierlinski/private/bsub_comp/de_genes)
- [Differential expression for operons](https://shiny.compbio.dundee.ac.uk/mgierlinski/private/bsub_comp/de_operons)

## Downloads

- [Differential expression for genes](https://www.compbio.dundee.ac.uk/user/mgierlinski/bsub_comp/tab/dea.csv)
- [Differential expression for operons](https://www.compbio.dundee.ac.uk/user/mgierlinski/bsub_comp/tab/dea_ops.csv)
- [Gene set enrichment for genes](https://www.compbio.dundee.ac.uk/user/mgierlinski/bsub_comp/tab/gsea.csv)
- [Gene set enrichment for operons](https://www.compbio.dundee.ac.uk/user/mgierlinski/bsub_comp/tab/gsea_ops.csv)

## Code

-   [R code in GitHub](https://github.com/bartongroup/MG_BSubComp)

# Session info {#sec-session-info}

```{r}
#| label: session-info
#| cache: false
targets::tar_load(session_info)
```

```{r}
#| label: gt_session
gt_session <- function(s) {
  s |> 
    gt::gt() |> 
    gt::tab_options(
      table.align = "left",
      data_row.padding = gt::px(3)
    )
#    gt::opt_table_font(
#      font = c(
#        gt::google_font(name = "Roboto Mono"),
#        gt::default_fonts()
#      )
#    )
}
```

### Platform

```{r}
#| label: session-info-platform
#| cache: false
session_info$platform |>
  unlist() |>
  tibble::as_tibble(rownames = "Setting") |> 
  dplyr::rename(Value = value) |> 
  gt_session() |> 
  gt::cols_width(
    Setting ~ gt::px(150)
  )
```

### Packages

```{r}
#| label: session-info-packages
#| cache: false
session_info$packages |>
  tibble::as_tibble() |>
  dplyr::filter(attached == TRUE) |> 
  dplyr::select(Package = package, Version = loadedversion, Date = date, Source = source) |> 
  gt_session() |> 
  gt::cols_width(
    Package ~ gt::px(150),
    Version ~ gt::px(80),
    Date ~ gt::px(150),
    Source ~ gt::px(400)
  )
```